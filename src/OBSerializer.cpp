/*
 * Copyright (C) 2017 John M. Harris, Jr. <johnmh@openblox.org>
 *
 * This file is part of OpenBlox.
 *
 * OpenBlox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenBlox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the Lesser GNU General Public License
 * along with OpenBlox.	 If not, see <https://www.gnu.org/licenses/>.
 */

#include "OBSerializer.h"

#include "OBEngine.h"

#if HAVE_PUGIXML
#include "ClassFactory.h"

#include "config.h"

#include "utility.h"

#include <sstream>

#include <pugixml.hpp>
#endif

namespace OB{
	OBSerializer::OBSerializer(OBEngine* eng){
		this->eng = eng;
	}

#if HAVE_PUGIXML
	// Attempts to convert file paths to file:// URI
	std::string _ob_obserializer_load_uri_to_std(std::string ouri){
		if(ouri.at(0) == '/'){
			char* canonPath = realpath(ouri.c_str(), NULL);
			if(canonPath){
				if(canonPath[0] == '/'){
					std::string retStr = std::string(canonPath);
					free(canonPath);
					return "file://" + retStr;
				}
			}
		}
		return ouri;
	}

	shared_ptr<Instance::Instance> OBSerializer::LoadModelFromMemory(char* buf, size_t size){

	}

	shared_ptr<Instance::Instance> OBSerializer::LoadModel(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		return NULL;
	}

	bool OBSerializer::LoadFromMemory(char* buf, size_t size){
		pugi::xml_document doc;
		pugi::xml_parse_result result = doc.load_buffer(buf, size, pugi::parse_cdata | pugi::parse_escapes | pugi::parse_wconv_attribute | pugi::parse_eol | pugi::parse_pi, pugi::encoding_utf8);

		if(!result){
			printf("XML Parser Error: %s\n", result.description());

			return false;
		}

		pugi::xml_node game_node = doc.child("game");
		if(!game_node){
			puts("File not in game format.");

			return false;
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		dm->deserialize(game_node);

		instanceMap.clear();
		dynamic_instance_count = 0;

		return true;
	}

	bool OBSerializer::Load(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		if(eng){
			shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
			if(assetLoc){
				assetLoc->loadAssetSync(loadURI, false, true);
				shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
				if(resp){
					return LoadFromMemory(resp->getData(), resp->getSize());
				}
			}
		}

		return false;
	}

	void _ob_obserializer_add_warning(pugi::xml_document &doc){
		pugi::xml_node editing_comment = doc.append_child(pugi::node_comment);
		editing_comment.set_value("\nThis file was generated by " PACKAGE_STRING "\n");
	}

	bool OBSerializer::SaveModel(shared_ptr<Instance::Instance> model, std::string file){
		if(!model){
			return false;
		}

		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		pugi::xml_node model_node = doc.append_child(pugi::node_element);
		model_node.set_name("model");
		model_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		instanceMap.clear();
		dynamic_instance_count = 0;

		model->serializeThis(model_node, model);

		instanceMap.clear();
		dynamic_instance_count = 0;

		return doc.save_file(file.c_str(), "\t", pugi::format_indent, pugi::encoding_utf8);
	}

	std::string OBSerializer::SaveModelInMemory(shared_ptr<Instance::Instance> model){
		if(!model){
			return "";
		}

		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		pugi::xml_node model_node = doc.append_child(pugi::node_element);
		model_node.set_name("model");
		model_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		instanceMap.clear();
		dynamic_instance_count = 0;

		model->serializeThis(model_node, model);

		instanceMap.clear();
		dynamic_instance_count = 0;

		std::stringstream ss;
		doc.save(ss, "\t", pugi::format_indent, pugi::encoding_utf8);

		return ss.str();
	}

	bool OBSerializer::Save(std::string file){
		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		pugi::xml_node game_node = doc.append_child(pugi::node_element);
		game_node.set_name("game");
		game_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		instanceMap.clear();
		dynamic_instance_count = 0;

		//We don't *need* to know it's a DataModel
		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		if(dm){
			dm->serializeThis(game_node, NULL);
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		return doc.save_file(file.c_str(), "\t", pugi::format_indent, pugi::encoding_utf8);
	}

	std::string OBSerializer::SaveInMemory(){
		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		instanceMap.clear();
		dynamic_instance_count = 0;

		pugi::xml_node game_node = doc.append_child(pugi::node_element);
		game_node.set_name("game");
		game_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		//We don't *need* to know it's a DataModel
		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		if(dm){
			dm->serializeThis(game_node, NULL);
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		std::stringstream ss;
		doc.save(ss, "\t", pugi::format_indent, pugi::encoding_utf8);

		return ss.str();
	}
#endif

	std::string OBSerializer::GetID(shared_ptr<Instance::Instance> inst){
		auto it = instanceMap.find(inst);
		if(it != instanceMap.end()){
			return it->second;
		}else{
			std::string id_str = "OBX_" + std::to_string(dynamic_instance_count);
			dynamic_instance_count++;
			instanceMap[inst] = id_str;
			return id_str;
		}
	}

	shared_ptr<Instance::Instance> OBSerializer::GetByID(std::string id){
		if(id == "NULL"){
			return NULL;
		}
		shared_ptr<Instance::DataModel> dm = eng->getDataModel();
		if(id == "game"){
			return dm;
		}
		shared_ptr<Instance::Instance> inst = dm->FindService(id);
		if(inst){
			return inst;
		}

		for(auto it = instanceMap.begin(); it != instanceMap.end(); it++){
			shared_ptr<Instance::Instance> inst = it->first;
			std::string iid = it->second;

			if(id == iid){
				return inst;
			}
		}
		return NULL;
	}

	void OBSerializer::SetID(shared_ptr<Instance::Instance> inst, std::string newId){
		instanceMap[inst] = newId;
	}
}
