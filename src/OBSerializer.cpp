/*
 * Copyright (C) 2017 John M. Harris, Jr. <johnmh@openblox.org>
 *
 * This file is part of OpenBlox.
 *
 * OpenBlox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenBlox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the Lesser GNU General Public License
 * along with OpenBlox.	 If not, see <https://www.gnu.org/licenses/>.
 */

#include "OBSerializer.h"

#include "OBEngine.h"

#if HAVE_PUGIXML
#include "ClassFactory.h"

#include "config.h"

#include <sstream>

#include <pugixml.hpp>
#endif

namespace OB{
	OBSerializer::OBSerializer(OBEngine* eng){
		this->eng = eng;
	}

	#if HAVE_PUGIXML
	// Attempts to convert file paths to file:// URI
	std::string _ob_obserializer_load_uri_to_std(std::string ouri){
	    if(ouri.at(0) == '/'){
			char* canonPath = realpath(ouri.c_str(), NULL);
			if(canonPath){
				if(canonPath[0] == '/'){
					std::string retStr = std::string(canonPath);
					free(canonPath);
					return "file://" + retStr;
				}
			}
		}
		return ouri;
	}
	
	shared_ptr<Instance::Instance> OBSerializer::LoadInstance(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);
		
		return NULL;
	}

	shared_ptr<Instance::Instance> OBSerializer::Load(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		pugi::xml_document doc;
		char* docBuf = NULL;

		if(eng){
			shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
			if(assetLoc){
				assetLoc->loadAssetSync(loadURI, false, true);
				shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
				if(resp){
					docBuf = new char[resp->getSize()];
					pugi::xml_parse_result result = doc.load_buffer_inplace(docBuf, resp->getSize());
					if(!result){
						if(docBuf){
							delete[] docBuf;
						}
		
						return NULL;
					}
				}
			}
		}

		

		if(docBuf){
			delete[] docBuf;
		}
		
		return NULL;
	}

	void _ob_obserializer_add_warning(pugi::xml_document &doc){
		pugi::xml_node editing_comment = doc.append_child(pugi::node_comment);
		editing_comment.set_value("\nThis file was generated by " PACKAGE_STRING "\n");
	}

	bool OBSerializer::SaveInstance(shared_ptr<Instance::Instance> inst, std::string file){
		if(!inst){
			return false;
		}

		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		inst->serialize(doc);
		
		return doc.save_file(file.c_str(), "\t", pugi::format_indent, pugi::encoding_utf8);
	}

	bool OBSerializer::Save(std::string file){
		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		//We don't *need* to know it's a DataModel
		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		if(dm){
			dm->serialize(doc);
		}
		
		return doc.save_file(file.c_str(), "\t", pugi::format_indent, pugi::encoding_utf8);
	}

	std::string OBSerializer::SaveInMemory(){
		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		//We don't *need* to know it's a DataModel
		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		if(dm){
			dm->serialize(doc);
		}

		std::stringstream ss;
	    doc.save(ss, "\t", pugi::format_indent, pugi::encoding_utf8);

		return ss.str();
	}
	#endif
}
