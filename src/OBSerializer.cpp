/*
 * Copyright (C) 2017 John M. Harris, Jr. <johnmh@openblox.org>
 *
 * This file is part of OpenBlox.
 *
 * OpenBlox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenBlox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the Lesser GNU General Public License
 * along with OpenBlox. If not, see <https://www.gnu.org/licenses/>.
 */

#include "OBSerializer.h"

#include "OBEngine.h"
#include "ClassFactory.h"
#include "BitStream.h"

#include "config.h"
#include "utility.h"

#if HAVE_PUGIXML
#include <sstream>

#include <pugixml.hpp>
#endif

namespace OB{
	OBSerializer::OBSerializer(OBEngine* eng){
		this->eng = eng;
	}

	// Attempts to convert file paths to file:// URI
	std::string _ob_obserializer_load_uri_to_std(std::string ouri){
		char* canonPath = realpath(ouri.c_str(), NULL);
		if(canonPath){
			if(canonPath[0] == '/'){
				std::string retStr = std::string(canonPath);
				free(canonPath);
				return "file://" + retStr;
			}
		}
		return ouri;
	}

#if HAVE_PUGIXML
    shared_ptr<Instance::Instance> OBSerializer::LoadModelFromMemory_XML(char* buf, size_t size){
	    pugi::xml_document doc;
		pugi::xml_parse_result result = doc.load_buffer(buf, size, pugi::parse_cdata | pugi::parse_escapes | pugi::parse_wconv_attribute | pugi::parse_eol | pugi::parse_pi, pugi::encoding_utf8);

		if(!result){
			printf("XML Parser Error: %s\n", result.description());

			return NULL;
		}

		pugi::xml_node model_node = doc.child("model");
		if(!model_node){
			puts("File not in model format.");

			return NULL;
		}

		pugi::xml_attribute itype = model_node.attribute("type");
		pugi::xml_attribute iid = model_node.attribute("id");

		if(itype.empty() || iid.empty()){
			puts("Invalid model data.");

			return NULL;
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		std::string stype = itype.as_string();
		std::string sid = iid.as_string();

	    shared_ptr<Instance::Instance> tInst = ClassFactory::createReplicate(stype, eng);
		if(!tInst){
			return NULL;
		}

		SetID(tInst, sid);

		tInst->deserialize(model_node);

		instanceMap.clear();
		dynamic_instance_count = 0;

		return tInst;
	}

	shared_ptr<Instance::Instance> OBSerializer::LoadModel_XML(std::string resURI){
	    std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		if(eng){
			shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
			if(assetLoc){
				assetLoc->loadAssetSync(loadURI, false, true);
				shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
				if(resp){
					return LoadModelFromMemory_XML(resp->getData(), resp->getSize());
				}
			}
		}

		return NULL;
	}

	bool OBSerializer::LoadFromMemory_XML(char* buf, size_t size){
		pugi::xml_document doc;
		pugi::xml_parse_result result = doc.load_buffer(buf, size, pugi::parse_cdata | pugi::parse_escapes | pugi::parse_wconv_attribute | pugi::parse_eol | pugi::parse_pi, pugi::encoding_utf8);

		if(!result){
			printf("XML Parser Error: %s\n", result.description());

			return false;
		}

		pugi::xml_node game_node = doc.child("game");
		if(!game_node){
			puts("File not in game format.");

			return false;
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		dm->deserialize(game_node);

		instanceMap.clear();
		dynamic_instance_count = 0;

		return true;
	}

	bool OBSerializer::Load_XML(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		if(eng){
			shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
			if(assetLoc){
				assetLoc->loadAssetSync(loadURI, false, true);
				shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
				if(resp){
					return LoadFromMemory_XML(resp->getData(), resp->getSize());
				}
			}
		}

		return false;
	}

	void _ob_obserializer_xml_add_warning(pugi::xml_document &doc){
		pugi::xml_node editing_comment = doc.append_child(pugi::node_comment);
		editing_comment.set_value("\nThis file was generated by " PACKAGE_STRING "\n");
	}

	bool OBSerializer::SaveModel_XML(shared_ptr<Instance::Instance> model, std::string file){
		if(!model){
			return false;
		}

		pugi::xml_document doc;

		_ob_obserializer_xml_add_warning(doc);

		pugi::xml_node model_node = doc.append_child(pugi::node_element);
		model_node.set_name("model");
		model_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		instanceMap.clear();
		dynamic_instance_count = 0;

		model->serializeThis(model_node, model);

		instanceMap.clear();
		dynamic_instance_count = 0;

		return doc.save_file(file.c_str(), "\t", pugi::format_indent, pugi::encoding_utf8);
	}

	std::string OBSerializer::SaveModelInMemory_XML(shared_ptr<Instance::Instance> model){
		if(!model){
			return "";
		}

		pugi::xml_document doc;

		_ob_obserializer_xml_add_warning(doc);

		pugi::xml_node model_node = doc.append_child(pugi::node_element);
		model_node.set_name("model");
		model_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		instanceMap.clear();
		dynamic_instance_count = 0;

		model->serializeThis(model_node, model);

		instanceMap.clear();
		dynamic_instance_count = 0;

		std::stringstream ss;
		doc.save(ss, "\t", pugi::format_indent, pugi::encoding_utf8);

		return ss.str();
	}

	bool OBSerializer::Save_XML(std::string file){
		pugi::xml_document doc;

		_ob_obserializer_xml_add_warning(doc);

		pugi::xml_node game_node = doc.append_child(pugi::node_element);
		game_node.set_name("game");
		game_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		instanceMap.clear();
		dynamic_instance_count = 0;

		//We don't *need* to know it's a DataModel
		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		if(dm){
			dm->serializeThis(game_node, NULL);
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		return doc.save_file(file.c_str(), "\t", pugi::format_indent, pugi::encoding_utf8);
	}

	std::string OBSerializer::SaveInMemory_XML(){
		pugi::xml_document doc;

		_ob_obserializer_xml_add_warning(doc);

		instanceMap.clear();
		dynamic_instance_count = 0;

		pugi::xml_node game_node = doc.append_child(pugi::node_element);
		game_node.set_name("game");
		game_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		//We don't *need* to know it's a DataModel
		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		if(dm){
			dm->serializeThis(game_node, NULL);
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		std::stringstream ss;
		doc.save(ss, "\t", pugi::format_indent, pugi::encoding_utf8);

		return ss.str();
	}
#endif

	shared_ptr<Instance::Instance> OBSerializer::LoadModelFromMemory_binary(char* buf, size_t size){
		return NULL; // stub
	}

	shared_ptr<Instance::Instance> OBSerializer::LoadModel_binary(std::string resURI){
	    std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		if(eng){
			shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
			if(assetLoc){
				assetLoc->loadAssetSync(loadURI, false, true);
				shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
				if(resp){
					return LoadModelFromMemory_binary(resp->getData(), resp->getSize());
				}
			}
		}

		return NULL;
	}

	bool OBSerializer::LoadFromMemory_binary(char* buf, size_t size){
		return false; // stub
	}

	bool OBSerializer::Load_binary(std::string resURI){
	    std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		if(eng){
			shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
			if(assetLoc){
				assetLoc->loadAssetSync(loadURI, false, true);
				shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
				if(resp){
					return LoadFromMemory_binary(resp->getData(), resp->getSize());
				}
			}
		}

		return false;
	}

	bool OBSerializer::SaveModel_binary(shared_ptr<Instance::Instance> model, std::string file){
		return false; // stub
	}

	BitStream* OBSerializer::SaveModelInMemory_binary(shared_ptr<Instance::Instance> model){
		return NULL; // stub
	}

	bool OBSerializer::Save_binary(std::string file){
		return false; // stub
	}

	BitStream* OBSerializer::SaveInMemory_binary(){
		return NULL; // stub
	}

	bool OBSerializer::IsBinaryFormat(char* buf, size_t size){
		if(size > 3){
			return (buf[0] == 'O' && buf[1] == 'B' && buf[2] == 'G');
		}
		return false;
	}

	shared_ptr<Instance::Instance> OBSerializer::LoadModelFromMemory(char* buf, size_t size){
		if(IsBinaryFormat(buf, size)){
			return LoadModelFromMemory_binary(buf, size);
		}else{
			return LoadModelFromMemory_XML(buf, size);
		}
	}

	shared_ptr<Instance::Instance> OBSerializer::LoadModel(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		if(ob_str_endsWith(loadURI, ".obgx")){
			return LoadModel_XML(resURI);
		}else{
			if(eng){
				shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
				if(assetLoc){
					assetLoc->loadAssetSync(loadURI, false, true);
					shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
					if(resp){
						return LoadModelFromMemory(resp->getData(), resp->getSize());
					}
				}
			}
		}

		return NULL;
	}

	bool OBSerializer::LoadFromMemory(char* buf, size_t size){
	    if(IsBinaryFormat(buf, size)){
			return LoadFromMemory_binary(buf, size);
		}else{
			return LoadFromMemory_XML(buf, size);
		}
	}

	bool OBSerializer::Load(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		if(ob_str_endsWith(loadURI, ".obgx")){
			return Load_XML(resURI);
		}else{
			if(eng){
				shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
				if(assetLoc){
					assetLoc->loadAssetSync(loadURI, false, true);
					shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
					if(resp){
						return LoadFromMemory(resp->getData(), resp->getSize());
					}
				}
			}
		}

		return false;
	}

	std::string OBSerializer::GetID(shared_ptr<Instance::Instance> inst){
		auto it = instanceMap.find(inst);
		if(it != instanceMap.end()){
			return it->second;
		}else{
			std::string id_str = "OBX_" + std::to_string(dynamic_instance_count);
			dynamic_instance_count++;
			instanceMap[inst] = id_str;
			return id_str;
		}
	}

	bool OBSerializer::HasID(shared_ptr<Instance::Instance> inst){
		auto it = instanceMap.find(inst);
	    bool hasInMap = (it != instanceMap.end());
		if(!hasInMap){
			std::string fixedStr = inst->fixedSerializedID();
			if(!fixedStr.empty()){
				SetID(inst, fixedStr);
				return true;
			}
		}
		return hasInMap;
	}

	shared_ptr<Instance::Instance> OBSerializer::GetByID(std::string id){
		if(id == "NULL"){
			return NULL;
		}
		shared_ptr<Instance::DataModel> dm = eng->getDataModel();
		if(id == "game"){
			return dm;
		}
		shared_ptr<Instance::Instance> inst = dm->FindService(id);
		if(inst){
			return inst;
		}

		for(auto it = instanceMap.begin(); it != instanceMap.end(); it++){
			shared_ptr<Instance::Instance> inst = it->first;
			std::string iid = it->second;

			if(id == iid){
				return inst;
			}
		}
		return NULL;
	}

	void OBSerializer::SetID(shared_ptr<Instance::Instance> inst, std::string newId){
		instanceMap[inst] = newId;
	}
}
