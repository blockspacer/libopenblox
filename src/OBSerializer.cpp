/*
 * Copyright (C) 2017 John M. Harris, Jr. <johnmh@openblox.org>
 *
 * This file is part of OpenBlox.
 *
 * OpenBlox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenBlox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the Lesser GNU General Public License
 * along with OpenBlox.	 If not, see <https://www.gnu.org/licenses/>.
 */

#include "OBSerializer.h"

#include "OBEngine.h"

#if HAVE_PUGIXML
#include "ClassFactory.h"

#include "config.h"

#include "utility.h"

#include <sstream>

#include <pugixml.hpp>
#endif

namespace OB{
	OBSerializer::OBSerializer(OBEngine* eng){
		this->eng = eng;
	}

	#if HAVE_PUGIXML
	// Attempts to convert file paths to file:// URI
	std::string _ob_obserializer_load_uri_to_std(std::string ouri){
	    if(ouri.at(0) == '/'){
			char* canonPath = realpath(ouri.c_str(), NULL);
			if(canonPath){
				if(canonPath[0] == '/'){
					std::string retStr = std::string(canonPath);
					free(canonPath);
					return "file://" + retStr;
				}
			}
		}
		return ouri;
	}
	
	shared_ptr<Instance::Instance> OBSerializer::LoadModel(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);
		
		return NULL;
	}

	shared_ptr<Instance::Instance> OBSerializer::Load(std::string resURI){
		std::string loadURI = _ob_obserializer_load_uri_to_std(resURI);

		pugi::xml_document doc;
		char* docBuf = NULL;

		instanceMap.clear();
		dynamic_instance_count = 0;

		if(eng){
			shared_ptr<AssetLocator> assetLoc = eng->getAssetLocator();
			if(assetLoc){
				assetLoc->loadAssetSync(loadURI, false, true);
				shared_ptr<AssetResponse> resp = assetLoc->getAsset(loadURI, false);
				if(resp){
					docBuf = new char[resp->getSize()];
					pugi::xml_parse_result result = doc.load_buffer_inplace(docBuf, resp->getSize());
					if(!result){
						if(docBuf){
							delete[] docBuf;
						}
		
						return NULL;
					}

					pugi::xml_node game_node = doc.child("game");
					if(!game_node){
						puts("File not in game format.");
						
						if(docBuf){
							delete[] docBuf;
						}
						
						return NULL;
					}

					shared_ptr<Instance::Instance> dm = eng->getDataModel();
					dm->deserialize(game_node);

					if(docBuf){
						delete[] docBuf;
					}

					return dm;
				}
			}
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		if(docBuf){
			delete[] docBuf;
		}
		
		return NULL;
	}

	void _ob_obserializer_add_warning(pugi::xml_document &doc){
		pugi::xml_node editing_comment = doc.append_child(pugi::node_comment);
		editing_comment.set_value("\nThis file was generated by " PACKAGE_STRING "\n");
	}

	bool OBSerializer::SaveModel(shared_ptr<Instance::Instance> model, std::string file){
		if(!model){
			return false;
		}

		instanceMap.clear();
		dynamic_instance_count = 0;

		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		pugi::xml_node model_node = doc.append_child(pugi::node_element);
		model_node.set_name("model");
		model_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

	    model->serialize(model_node);
		
		return doc.save_file(file.c_str(), "\t", pugi::format_indent, pugi::encoding_utf8);
	}

    std::string OBSerializer::SaveModelInMemory(shared_ptr<Instance::Instance> model){
		if(!model){
			return "";
		}

		instanceMap.clear();
		dynamic_instance_count = 0;
		
		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		pugi::xml_node model_node = doc.append_child(pugi::node_element);
		model_node.set_name("model");
		model_node.append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

	    model->serialize(model_node);
		
		std::stringstream ss;
	    doc.save(ss, "\t", pugi::format_indent, pugi::encoding_utf8);

		return ss.str();
	}

	bool OBSerializer::Save(std::string file){
		instanceMap.clear();
		dynamic_instance_count = 0;
		
		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		//We don't *need* to know it's a DataModel
		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		if(dm){
			dm->serialize(doc);
		}

		doc.child("game").append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);
		
		return doc.save_file(file.c_str(), "\t", pugi::format_indent, pugi::encoding_utf8);
	}

	std::string OBSerializer::SaveInMemory(){
		instanceMap.clear();
		dynamic_instance_count = 0;
		
		pugi::xml_document doc;

		_ob_obserializer_add_warning(doc);

		//We don't *need* to know it's a DataModel
		shared_ptr<Instance::Instance> dm = eng->getDataModel();
		if(dm){
			dm->serialize(doc);
		}

		doc.child("game").append_attribute("version").set_value(OB_SERIALIZER_XML_CURRENT_VERSION_ID);

		std::stringstream ss;
	    doc.save(ss, "\t", pugi::format_indent, pugi::encoding_utf8);

		return ss.str();
	}
	#endif

	std::string OBSerializer::GetID(shared_ptr<Instance::Instance> inst){
	    auto it = instanceMap.find(inst);
		if(it != instanceMap.end()){
			return it->second;
		}else{
			std::string id_str = "OBX_" + std::to_string(dynamic_instance_count);
			dynamic_instance_count++;
			instanceMap[inst] = id_str;
			return id_str;
		}
	}

	shared_ptr<Instance::Instance> OBSerializer::GetByID(std::string id){
		for(auto it = instanceMap.begin(); it != instanceMap.end(); it++){
			shared_ptr<Instance::Instance> inst = it->first;
			std::string iid = it->second;

			if(id == iid){
				return inst;
			}
		}
		return NULL;
	}

	void OBSerializer::SetID(shared_ptr<Instance::Instance> inst, std::string newId){
		instanceMap[inst] = newId;
	}
}
